<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux系统基础知识·3 | 靖</title><meta name="author" content="靖轩"><meta name="copyright" content="靖轩"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文基于马哥教育就业班第三周课程总结  软件管理 尝试基于gcc命令说明 c语言编译过程。C语言编译过程主要包括预处理、编译、汇编和链接四个阶段。gcc命令是一个常用的C语言编译器，可以完成这四个阶段的工作。 下面是gcc命令的使用示例和各个阶段的说明： 1. 预处理阶段主要是对源代码进行宏替换、"><link rel="shortcut icon" href="https://cdn.sujx.net/about/favicon.png"><link rel="canonical" href="https://www.sujx.net/2023/05/21/magedu-week-3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?417b20ac1984432f821159fac27d3bb5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":5,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统基础知识·3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-22 00:23:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="靖" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.sujx.net/about/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">179</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Posts</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-tv"></i><span> Movies</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="靖"><span class="site-name">靖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Posts</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-tv"></i><span> Movies</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux系统基础知识·3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-21T14:48:47.000Z" title="Created 2023-05-21 22:48:47">2023-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-21T16:23:09.604Z" title="Updated 2023-05-22 00:23:09">2023-05-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Education/">Education</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>26min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统基础知识·3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>本文基于马哥教育就业班第三周课程总结</p>
</blockquote>
<h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><ul>
<li>尝试基于gcc命令说明 c语言编译过程。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">C语言编译过程主要包括预处理、编译、汇编和链接四个阶段。gcc命令是一个常用的C语言编译器，可以完成这四个阶段的工作。
下面是gcc命令的使用示例和各个阶段的说明：
<span class="token number">1</span>. 预处理阶段主要是对源代码进行宏替换、头文件包含等操作，生成预处理后的代码。gcc命令中使用参数“-E”来进行预处理，示例命令如下：
$ gcc <span class="token parameter variable">-E</span> main.c <span class="token parameter variable">-o</span> main.i
<span class="token number">2</span>. 编译阶段主要是将预处理后的代码转换成汇编代码。gcc命令中使用参数“-S”来进行编译，示例命令如下：
$ gcc <span class="token parameter variable">-S</span> main.i <span class="token parameter variable">-o</span> main.s
<span class="token number">3</span>. 汇编阶段主要是将汇编代码转换成机器码。gcc命令中使用参数“-c”来进行汇编，示例命令如下：
$ gcc <span class="token parameter variable">-c</span> main.s <span class="token parameter variable">-o</span> main.o
<span class="token number">4</span>. 链接阶段主要是将多个目标文件链接成一个可执行文件。gcc命令中使用参数“-o”来指定输出文件名，示例命令如下：
$ gcc main.o <span class="token parameter variable">-o</span> main
以上是gcc命令的使用示例和C语言编译过程的各个阶段说明。在实际编译过程中，可以使用gcc命令的多个参数来控制编译过程的细节，例如优化级别、调试信息等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结程序包管理器有哪些，以及包中包含什么内容的文件，尝试这些文件如何获取命令获取？ yum&#x2F;dnf&#x2F;apt<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>. 程序包通常包含以下内容的文件：
可执行文件：程序的主要执行文件，通常存放在/bin、/usr/bin、/sbin、/usr/sbin等目录下
库文件：程序所依赖的库文件，通常存放在/lib、/usr/lib、/usr/local/lib等目录下
配置文件：程序的配置文件，通常存放在/etc目录下。
文档文件：程序的文档文件，通常存放在/usr/share/doc目录下
其他文件：程序所需要的其他文件，如图标、音频、视频等文件

<span class="token number">2</span>. 以下是常见的程序包管理器及其命令：
yum/dnf：适用于Red Hat、CentOS等基于RPM的Linux发行版:
安装程序包：sudo yum/dnf <span class="token function">install</span> package_name
卸载程序包：sudo yum/dnf remove package_name
更新程序包：sudo yum/dnf update package_name
搜索程序包：sudo yum/dnf search package_name
查看程序包信息：sudo yum/dnf info package_name

<span class="token number">3</span>. apt：适用于Debian、Ubuntu等基于Debian的Linux发行版:
安装程序包：sudo <span class="token function">apt-get</span> <span class="token function">install</span> package_name
卸载程序包：sudo <span class="token function">apt-get</span> remove package_name
更新程序包：sudo <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade
搜索程序包：sudo <span class="token function">apt-cache</span> search package_name
查看程序包信息：sudo <span class="token function">apt-cache</span> show package_name

<span class="token number">4</span>. pacman：适用于Arch Linux发行版:
安装程序包：sudo pacman <span class="token parameter variable">-S</span> package_name
卸载程序包：sudo pacman <span class="token parameter variable">-R</span> package_name
更新程序包：sudo pacman <span class="token parameter variable">-Syu</span>
搜索程序包：sudo pacman <span class="token parameter variable">-Ss</span> package_name
查看程序包信息：sudo pacman <span class="token parameter variable">-Si</span> package_name

以上是常见的程序包管理器及其命令，可以根据实际需求选择合适的程序包管理器。获取命令可以通过man命令查看程序包管理器的帮助文档，或者在终端中输入程序包管理器的命令加上-h或–help参数获取帮助信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结程序包获取途径，以及rpm, yum, apt命令选项示例<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">程序包获取途径主要有以下几种：
官方软件仓库：操作系统或发行版官方提供的软件仓库，可以通过程序包管理器进行访问和下载
第三方软件仓库：由第三方提供的软件仓库，可以通过程序包管理器进行访问和下载
官方网站：软件开发者或厂商官方网站提供的下载链接，可以通过浏览器进行访问和下载
第三方网站：由第三方提供的软件下载网站，可以通过浏览器进行访问和下载

以下是rpm、yum和apt命令的选项示例：
<span class="token number">1</span>. rpm命令选项示例
安装程序包：sudo <span class="token function">rpm</span> <span class="token parameter variable">-ivh</span> package_name.rpm
卸载程序包：sudo <span class="token function">rpm</span> <span class="token parameter variable">-e</span> package_name
查看程序包信息：sudo <span class="token function">rpm</span> <span class="token parameter variable">-qi</span> package_name
查看程序包文件列表：sudo <span class="token function">rpm</span> <span class="token parameter variable">-ql</span> package_name
查看程序包依赖关系：sudo <span class="token function">rpm</span> <span class="token parameter variable">-qR</span> package_name

<span class="token number">2</span>. yum命令选项示例
安装程序包：sudo yum <span class="token function">install</span> package_name
卸载程序包：sudo yum remove package_name
更新程序包：sudo yum update package_name
搜索程序包：sudo yum search package_name
查看程序包信息：sudo yum info package_name

<span class="token number">3</span>. apt命令选项示例
安装程序包：sudo <span class="token function">apt-get</span> <span class="token function">install</span> package_name
卸载程序包：sudo <span class="token function">apt-get</span> remove package_name
更新程序包：sudo <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade
搜索程序包：sudo <span class="token function">apt-cache</span> search package_name
查看程序包信息：sudo <span class="token function">apt-cache</span> show package_name

以上是程序包获取途径和rpm、yum、apt命令的选项示例，可以根据实际需求选择合适的获取途径和命令选项。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>简要总结yum&#x2F;dnf工作原理。并搭建私有yum仓库(base, epel源）给另一个虚拟机使用<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum/dnf是基于RPM包管理器的程序包管理器，主要用于在Linux系统中安装、升级和卸载软件包。其工作原理如下：
  配置软件仓库：yum/dnf通过配置软件仓库来获取软件包信息。软件仓库可以是本地的、远程的或者是第三方的。
  搜索软件包：yum/dnf通过搜索软件仓库来查找需要安装的软件包。
  下载软件包：yum/dnf会从软件仓库中下载需要安装的软件包及其依赖的软件包。
  安装软件包：yum/dnf会自动解决软件包之间的依赖关系，并安装需要的软件包。
  升级软件包：yum/dnf会检查软件仓库中是否有新版本的软件包，并自动升级已安装的软件包。
  卸载软件包：yum/dnf会自动卸载不再需要的软件包，并删除其依赖的软件包。

<span class="token number">1</span>. 搭建私有yum仓库
<span class="token comment"># 安装httpd和createrepo</span>
yum <span class="token function">install</span> httpd createrepo
<span class="token comment"># 设置httpd服务开机自启动并启动服务</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token parameter variable">--now</span> httpd
<span class="token comment"># 创建yum仓库目录</span>
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/www/html/yum/base
<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/www/html/yum/epel
<span class="token comment"># 复制软件包到yum仓库目录</span>
<span class="token comment"># 将需要的软件包复制到对应的yum仓库目录中。</span>

<span class="token comment"># 创建base源的yum仓库</span>
createrepo /var/www/html/yum/base
<span class="token comment"># 创建epel源的yum仓库</span>
createrepo /var/www/html/yum/epel

<span class="token number">2</span>. 使用yum仓库
在另一个虚拟机中，编辑yum仓库配置文件/etc/yum.repos.d/myrepo.repo，添加以下内容：
<span class="token comment">#yum_server_ip为搭建yum仓库的服务器的IP地址。</span>
<span class="token punctuation">[</span>base<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>My Base Repository
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://yum_server_ip/yum/base
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>

<span class="token punctuation">[</span>epel<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>My EPEL Repository
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://yum_server_ip/yum/epel
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">0</span>

<span class="token number">3</span>.测试yum仓库
在另一个虚拟机中，使用yum命令测试yum仓库是否可用：
<span class="token comment"># 更新yum仓库缓存</span>
yum makecache
<span class="token comment"># 搜索软件包</span>
 yum search package_name
<span class="token comment"># 安装软件包</span>
yum <span class="token function">install</span> package_name

以上是yum/dnf工作原理的简要总结和搭建私有yum仓库的步骤，可以根据实际需求进行配置和使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结系统安装之后的常用初始化步骤。rocky&#x2F;ubuntu</li>
</ul>
<ol>
<li><a href="https://www.sujx.net/2021/05/08/centos8-make-template/">制作CentOS8模板</a></li>
<li><a href="https://www.sujx.net/2021/06/28/ubuntu-template-on-hyperv/">制作Ubuntu模板</a></li>
</ol>
<ul>
<li>解读一键安装httpd脚本，并自行实现一个一键安装脚本，要求<br>1）基于位置变量传递版本号<br>2）基于独立函数进行初始化步骤，禁用防火墙，安装开发依赖包。<br>3）基于独立函数进行下载包，解压包。<br>4）基于独立函数进行编译，安装包。<br>5）基于独立函数完成链接包。<br>6）启动服务，并输出自定义的语句，安装xxx服务<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">以下是一个示例的一键安装脚本，安装的是 Apache httpd 服务器：

<span class="token comment">#!/bin/bash</span>
<span class="token comment"># 定义变量</span>
<span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token variable">$1</span>
<span class="token assign-left variable">httpd_url</span><span class="token operator">=</span><span class="token string">"https://mirrors.tuna.tsinghua.edu.cn/apache/httpd/httpd-<span class="token variable">$version</span>.tar.gz"</span>
<span class="token assign-left variable">httpd_dir</span><span class="token operator">=</span><span class="token string">"httpd-<span class="token variable">$version</span>"</span>

<span class="token comment"># 初始化步骤</span>
<span class="token keyword">function</span> <span class="token function-name function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment"># 禁用防火墙</span>
  systemctl stop firewalld
  systemctl disable firewalld
  <span class="token comment"># 安装开发依赖包</span>
  yum <span class="token function">install</span> <span class="token parameter variable">-y</span> gcc <span class="token function">make</span> apr-devel apr-util-devel pcre-devel
<span class="token punctuation">&#125;</span>

<span class="token comment"># 下载包</span>
<span class="token keyword">function</span> <span class="token function-name function">download</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">wget</span> <span class="token variable">$httpd_url</span>
  <span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> <span class="token variable">$httpd_dir</span>.tar.gz
<span class="token punctuation">&#125;</span>

<span class="token comment"># 编译、安装包</span>
<span class="token keyword">function</span> <span class="token function-name function">install</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token builtin class-name">cd</span> <span class="token variable">$httpd_dir</span>
  ./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/httpd
  <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
<span class="token punctuation">&#125;</span>

<span class="token comment"># 链接包</span>
<span class="token keyword">function</span> <span class="token function-name function">link</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/local/httpd/bin/apachectl /usr/bin/apachectl
<span class="token punctuation">&#125;</span>

<span class="token comment"># 启动服务</span>
<span class="token keyword">function</span> <span class="token function-name function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  /usr/local/httpd/bin/apachectl start
  <span class="token builtin class-name">echo</span> <span class="token string">"Apache httpd <span class="token variable">$version</span> has been installed."</span>
<span class="token punctuation">&#125;</span>

<span class="token comment"># 执行函数</span>
init
<span class="token function">sleep</span> <span class="token number">1</span>

download
<span class="token function">sleep</span> <span class="token number">1</span>

<span class="token function">install</span>
<span class="token function">sleep</span> <span class="token number">1</span>

<span class="token function">link</span>
<span class="token function">sleep</span> <span class="token number">1</span>

start


该脚本的原理是：
定义了变量 version、httpd_url 和 httpd_dir，分别表示 httpd 的版本号、下载链接和解压后的目录名
定义了函数 init，用于禁用防火墙和安装开发依赖包
定义了函数 download，用于下载 httpd 包并解压
定义了函数 install，用于编译、安装 httpd 包
定义了函数 link，用于创建软链接
定义了函数 start，用于启动 httpd 服务并输出自定义的语句
在脚本的最后，按照顺序执行了 init、download、install、link 和 start 函数。
如果要使用该脚本安装 httpd，需要在命令行中指定 httpd 的版本号，例如：
./install_httpd.sh <span class="token number">2.4</span>.48<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul>
<li>总结开放系统互联OSI模型，每层作用及对应的协议。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">开放系统互联<span class="token punctuation">(</span>OSI<span class="token punctuation">)</span>模型是一个由国际标准化组织<span class="token punctuation">(</span>ISO<span class="token punctuation">)</span>制定的网络通信协议参考模型，它将网络通信分为七个层次，每个层次都有自己的功能和协议。
<span class="token number">1</span>. 物理层：负责传输比特流，即0和1的电信号，以及定义物理接口和传输介质。常用的协议有：IEEE <span class="token number">802.3</span>、IEEE <span class="token number">802.5</span>、RS-232、V.35等
<span class="token number">2</span>. 数据链路层：负责将比特流组装成帧，并进行差错检测和纠正。常用的协议有：PPP、HDLC、Ethernet、Token Ring等
<span class="token number">3</span>. 网络层：负责将数据包从源地址传输到目的地址，实现路由和拥塞控制。常用的协议有：IP、ICMP、ARP、RARP等
<span class="token number">4</span>. 传输层：负责提供端到端的可靠数据传输和错误恢复。常用的协议有：TCP、UDP、SPX等
<span class="token number">5</span>. 会话层：负责建立、管理和终止会话，实现数据交换和同步。常用的协议有：RPC、SQL、NFS等
<span class="token number">6</span>. 表示层：负责数据格式转换、加密解密、压缩解压缩等。常用的协议有：JPEG、MPEG、ASCII、EBCDIC等
<span class="token number">7</span>. 应用层：负责提供各种网络应用服务，如电子邮件、文件传输、远程登录等。常用的协议有：HTTP、FTP、SMTP、POP3等
以上是OSI模型每层的作用及对应协议<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>调整动态端口范围为20000-60000<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在Linux主机上，可以通过修改/proc/sys/net/ipv4/ip_local_port_range文件来调整动态端口范围。
以下是将动态端口范围调整为20000-60000的步骤：
使用root用户登录Linux主机，修改/proc/sys/net/ipv4/ip_local_port_range文件
$ <span class="token function">sudo</span> <span class="token builtin class-name">echo</span> <span class="token string">"20000 60000"</span> <span class="token operator">></span> /proc/sys/net/ipv4/ip_local_port_range
验证动态端口范围是否已经修改成功
$ <span class="token function">cat</span> /proc/sys/net/ipv4/ip_local_port_range
如果输出结果为“20000 <span class="token number">60000</span>”，则说明动态端口范围已经修改成功。

注意：以上修改是临时的，重启系统后会恢复默认值。如果需要永久修改动态端口范围，可以在/etc/sysctl.conf文件中添加以下内容：
<span class="token comment"># 修改动态端口范围</span>
net.ipv4.ip_local_port_range <span class="token operator">=</span> <span class="token number">20000</span> <span class="token number">60000</span>
然后执行以下命令使修改生效：
$ <span class="token function">sudo</span> <span class="token function">sysctl</span> <span class="token parameter variable">-p</span>
以上是将Linux主机动态端口范围调整为20000-60000的步骤，可以根据实际需求进行调整。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结TCP包头结构，TCP三次握手，4次挥手<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">TCP是一种面向连接的、可靠的传输协议，它通过TCP包头中的控制信息来实现数据传输的可靠性和有序性。
以下是TCP包头结构、TCP三次握手和四次挥手的简要总结：

TCP包头结构
TCP包头结构由20个字节组成，包括以下字段：
源端口和目的端口：用于标识发送方和接收方的端口号。
序列号和确认号：用于实现数据传输的可靠性和有序性。
数据偏移和保留位：用于标识TCP包头长度和保留位。
标志位：用于标识TCP包的类型，如SYN、ACK、FIN等。
窗口大小：用于实现流量控制。
校验和：用于检测TCP包头和数据的完整性。
紧急指针：用于标识紧急数据的位置。

TCP三次握手
TCP三次握手是建立TCP连接的过程，包括以下步骤：
第一次握手：客户端向服务器发送SYN包，请求建立连接。
第二次握手：服务器收到SYN包后，向客户端发送SYN+ACK包，表示可以建立连接。
第三次握手：客户端收到SYN+ACK包后，向服务器发送ACK包，表示连接已经建立。

TCP四次挥手
TCP四次挥手是关闭TCP连接的过程，包括以下步骤：
第一次挥手：客户端向服务器发送FIN包，请求关闭连接。
第二次挥手：服务器收到FIN包后，向客户端发送ACK包，表示已经收到关闭请求。
第三次挥手：服务器向客户端发送FIN包，请求关闭连接。
第四次挥手：客户端收到FIN包后，向服务器发送ACK包，表示已经收到关闭请求。
以上是TCP包头结构、TCP三次握手和四次挥手的简要总结，可以帮助理解TCP协议的工作原理和数据传输过程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结主机到主机的包传递过程<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">主机到主机的包传递过程可以分为以下几个步骤：
  应用层：发送主机的应用程序将数据封装成应用层协议数据单元<span class="token punctuation">(</span>PDU<span class="token punctuation">)</span>，如HTTP、FTP、SMTP等。
  传输层：传输层协议将应用层PDU封装成传输层协议数据单元<span class="token punctuation">(</span>PDU<span class="token punctuation">)</span>，如TCP、UDP等。
  网络层：网络层协议将传输层PDU封装成网络层协议数据单元<span class="token punctuation">(</span>PDU<span class="token punctuation">)</span>，如IP、ICMP、ARP等。
  数据链路层：数据链路层协议将网络层PDU封装成数据链路层协议数据单元<span class="token punctuation">(</span>PDU<span class="token punctuation">)</span>，如Ethernet、PPP等。
  物理层：物理层协议将数据链路层PDU封装成比特流，通过物理介质传输到接收主机
  接收主机：接收主机将接收到的比特流转换成数据链路层PDU，然后依次解封装，直到应用层协议数据单元被传递到接收主机的应用程序
在传递过程中，每一层协议都会添加一些控制信息，如源地址、目的地址、端口号、序列号、确认号、校验和等，用于实现数据传输的可靠性、有序性和安全性。同时，每一层协议也会对数据进行一些处理，如分段、分组、路由、差错检测和纠正等，以保证数据能够正确地传输到目的主机。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>总结IP地址 A, B, C, D 类,并解析IP地址的组成<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IP地址是互联网协议中用于标识网络设备的地址，根据IP地址的不同分类，可以将其分为A、B、C、D四类。以下是IP地址A、B、C、D类的简要总结及其组成：
A类IP地址
A类IP地址的第一个字节范围是1~126，用于大型网络，其组成如下：
第一个字节：网络地址，后三个字节：主机地址

B类IP地址
B类IP地址的第一个字节范围是128~191，用于中型网络，其组成如下：
前两个字节：网络地址，后两个字节：主机地址

C类IP地址
C类IP地址的第一个字节范围是192~223，用于小型网络，其组成如下：
前三个字节：网络地址，最后一个字节：主机地址

D类IP地址
D类IP地址的第一个字节范围是224~239，用于多播地址，其组成如下：
第一个字节：1110开头，后三个字节：多播组标识

IP地址的组成包括网络地址和主机地址，其中网络地址用于标识网络，主机地址用于标识网络中的主机。IP地址的长度为32位，通常用点分十进制表示法表示，如192.168.1.1。IP地址的子网掩码用于划分网络地址和主机地址的边界，通常也用点分十进制表示法表示，如255.255.255.0。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>201.222.200.111&#x2F;18计算主机数？子网掩码？说明计算方法。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">根据IP地址201.222.200.111/18，可以计算出主机数和子网掩码，具体计算方法如下：
<span class="token number">1</span>. 计算子网掩码
子网掩码用于划分网络地址和主机地址的边界，根据CIDR表示法，/18表示前18位为网络地址，后14位为主机地址，因此子网掩码的前18位为1，后14位为0，即255.255.192.0。
<span class="token number">2</span>. 计算主机数
根据CIDR表示法，/18表示有14位用于主机地址，因此可以计算出主机数为2的14次方减2，即16382个主机。
综上所述，根据IP地址201.222.200.111/18，可以计算出子网掩码为255.255.192.0，主机数为16382个。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>当A(10.0.1.1&#x2F;16)与B(10.0.2.2&#x2F;24)通信，A如何判断是否在同一个网段？A和B能否通信？<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">A和B的IP地址分别为10.0.1.1/16和10.0.2.2/24，其中A的子网掩码为255.255.0.0，B的子网掩码为255.255.255.0。根据子网掩码的规则，如果两个主机的IP地址的网络地址相同，则它们在同一个网段中。因此，A和B的网络地址分别为10.0.0.0和10.0.2.0，不在同一个网段中。

由于A和B不在同一个网段中，它们不能直接通信。如果需要让它们通信，可以通过路由器或者三层交换机等设备进行中转，将数据包从一个网段转发到另一个网段。在这种情况下，需要在路由器或者三层交换机上配置路由表，以便正确地转发数据包。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>如何将10.0.0.0&#x2F;8划分32个子网？<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将10.0.0.0/8划分为32个子网，需要将原来的8位网络地址划分为更多的子网地址位。可以通过增加子网掩码的位数来实现，具体步骤如下：

<span class="token number">1</span>. 确定需要划分的子网数
将10.0.0.0/8划分为32个子网，需要确定需要划分的子网数为32个
<span class="token number">2</span>. 确定子网掩码
根据需要划分的子网数，可以计算出需要增加的子网掩码位数。由于32个子网需要使用5位二进制数来表示，因此需要将原来的8位网络地址中的5位作为子网地址位，剩余的3位作为主机地址位。因此，新的子网掩码为255.255.248.0
<span class="token number">3</span>.计算子网地址
根据新的子网掩码，可以计算出每个子网的子网地址。由于每个子网的子网地址位不同，因此需要逐个计算。以第一个子网为例，其子网地址为10.0.0.0，第二个子网的子网地址为10.0.8.0，以此类推。
<span class="token number">4</span>. 计算广播地址和可用主机数
根据新的子网掩码，可以计算出每个子网的广播地址和可用主机数。以第一个子网为例，其广播地址为10.0.7.255，可用主机数为2046个，第二个子网的广播地址为10.0.15.255，可用主机数为2046个，以此类推。
综上所述，将10.0.0.0/8划分为32个子网的步骤包括确定需要划分的子网数、确定子网掩码、计算子网地址、计算广播地址和可用主机数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>求每个子网的掩码，主机数。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">将10.0.0.0/8划分为32个子网后，每个子网的掩码和主机数如下：
子网1：10.0.0.0/21，掩码255.255.248.0，主机数2046
子网2：10.0.8.0/21，掩码255.255.248.0，主机数2046
子网3：10.0.16.0/21，掩码255.255.248.0，主机数2046
子网4：10.0.24.0/21，掩码255.255.248.0，主机数2046
子网5：10.0.32.0/21，掩码255.255.248.0，主机数2046
子网6：10.0.40.0/21，掩码255.255.248.0，主机数2046
子网7：10.0.48.0/21，掩码255.255.248.0，主机数2046
子网8：10.0.56.0/21，掩码255.255.248.0，主机数2046
子网9：10.0.64.0/21，掩码255.255.248.0，主机数2046
子网10：10.0.72.0/21，掩码255.255.248.0，主机数2046
子网11：10.0.80.0/21，掩码255.255.248.0，主机数2046
子网12：10.0.88.0/21，掩码255.255.248.0，主机数2046
子网13：10.0.96.0/21，掩码255.255.248.0，主机数2046
子网14：10.0.104.0/21，掩码255.255.248.0，主机数2046
子网15：10.0.112.0/21，掩码255.255.248.0，主机数2046
子网16：10.0.120.0/21，掩码255.255.248.0，主机数2046
子网17：10.0.128.0/21，掩码255.255.248.0，主机数2046
子网18：10.0.136.0/21，掩码255.255.248.0，主机数2046
子网19：10.0.144.0/21，掩码255.255.248.0，主机数2046
子网20：10.0.152.0/21，掩码255.255.248.0，主机数2046
子网21：10.0.160.0/21，掩码255.255.248.0，主机数2046
子网22：10.0.168.0/21，掩码255.255.248.0，主机数2046
子网23：10.0.176.0/21，掩码255.255.248.0，主机数2046
子网24：10.0.184.0/21，掩码255.255.248.0，主机数2046
子网25：10.0.192.0/21，掩码255.255.248.0，主机数2046
子网26：10.0.200.0/21，掩码255.255.248.0，主机数2046
子网27：10.0.208.0/21，掩码255.255.248.0，主机数2046
子网28：10.0.216.0/21，掩码255.255.248.0，主机数2046
子网29：10.0.224.0/21，掩码255.255.248.0，主机数2046
子网30：10.0.232.0/21，掩码255.255.248.0，主机数2046
子网31：10.0.240.0/21，掩码255.255.248.0，主机数2046
子网32：10.0.248.0/21，掩码255.255.248.0，主机数2046
每个子网的掩码都是255.255.248.0，主机数都是2046个。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>通过网络配置命令，让主机可以上网。 ip, netmask, gateway, dns，主机名。相关命令总结，最终可以通过这些配置让你的主机上网。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">要让主机能够上网，需要进行以下配置：IP地址、子网掩码、网关、DNS服务器和主机名。具体命令如下：
<span class="token comment"># 设置主机名</span>
hostnamectl set-hostname ostest
<span class="token comment"># 设置网络地址</span>
nmcli c m ens160 ipv4.method manual ipv4.addresses <span class="token number">192.168</span>.10.138/24 ipv4.gateway <span class="token number">192.168</span>.10.2 ipv4.dns <span class="token number">192.168</span>.10.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>解析&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0配置格式。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/etc/sysconfig/network-scripts/ifcfg-eth0 是 Linux 系统中用于配置网络接口 eth0 的文件。该文件的格式如下：

复制DEVICE<span class="token operator">=</span>eth0
<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>none
<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token number">192.168</span>.1.100
<span class="token assign-left variable">NETMASK</span><span class="token operator">=</span><span class="token number">255.255</span>.255.0
<span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1
<span class="token assign-left variable">DNS1</span><span class="token operator">=</span><span class="token number">8.8</span>.8.8
<span class="token assign-left variable">DNS2</span><span class="token operator">=</span><span class="token number">8.8</span>.4.4
各个字段的含义如下：

DEVICE：指定网络接口的名称，例如 eth0
BOOTPROTO：指定网络接口的启动协议，可以是 none、dhcp、bootp、static 等。none 表示不使用启动协议，需要手动配置 IP 地址等信息；dhcp 和 bootp 表示使用 DHCP 或 BOOTP 协议自动获取 IP 地址等信息；static 表示使用静态 IP 地址
ONBOOT：指定网络接口是否在系统启动时自动启用，可以是 <span class="token function">yes</span> 或 no
IPADDR：指定网络接口的 IP 地址
NETMASK：指定网络接口的子网掩码
GATEWAY：指定网络接口的默认网关
DNS1 和 DNS2：指定 DNS 服务器的 IP 地址，可以指定多个 DNS 服务器

这些字段的值可以根据需要进行修改，修改后需要重启网络服务或者重启系统才能生效。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>基于配置文件或命令完成bond0配置<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在 Linux 系统中，可以通过配置文件或命令来完成 bond0 的配置。下面分别介绍两种方法：

基于配置文件完成 bond0 配置

在 /etc/sysconfig/network-scripts/ 目录下创建一个名为 ifcfg-bond0 的文件，并添加以下内容：

<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>bond0
<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>none
<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes
<span class="token assign-left variable">BONDING_OPTS</span><span class="token operator">=</span><span class="token string">"mode=1 miimon=100"</span>
<span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token number">192.168</span>.1.100
<span class="token assign-left variable">NETMASK</span><span class="token operator">=</span><span class="token number">255.255</span>.255.0
<span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token number">192.168</span>.1.1
<span class="token assign-left variable">DNS1</span><span class="token operator">=</span><span class="token number">8.8</span>.8.8
<span class="token assign-left variable">DNS2</span><span class="token operator">=</span><span class="token number">8.8</span>.4.4
其中，DEVICE 指定了 bond0 的名称，BOOTPROTO 设置为 none 表示不使用启动协议，需要手动配置 IP 地址等信息，ONBOOT 设置为 <span class="token function">yes</span> 表示在系统启动时自动启用，BONDING_OPTS 指定了 bond0 的模式和心跳检测时间，IPADDR、NETMASK、GATEWAY、DNS1 和 DNS2 分别指定了 IP 地址、子网掩码、默认网关和 DNS 服务器的 IP 地址。

基于命令完成 bond0 配置

使用以下命令创建 bond0：

modprobe bonding
<span class="token builtin class-name">echo</span> <span class="token string">"alias bond0 bonding"</span> <span class="token operator">>></span> /etc/modprobe.d/bonding.conf
使用以下命令配置 bond0：

<span class="token function">ifconfig</span> bond0 <span class="token number">192.168</span>.1.100 netmask <span class="token number">255.255</span>.255.0 up
<span class="token builtin class-name">echo</span> <span class="token string">"192.168.1.1 via bond0"</span> <span class="token operator">>></span> /etc/sysconfig/network-scripts/route-bond0
<span class="token builtin class-name">echo</span> <span class="token string">"nameserver 8.8.8.8"</span> <span class="token operator">></span> /etc/resolv.conf
<span class="token builtin class-name">echo</span> <span class="token string">"nameserver 8.8.4.4"</span> <span class="token operator">>></span> /etc/resolv.conf
其中，modprobe bonding 命令加载 bonding 模块，echo <span class="token string">"alias bond0 bonding"</span> <span class="token operator">>></span> /etc/modprobe.d/bonding.conf 命令将 bond0 和 bonding 模块关联起来。ifconfig bond0 <span class="token number">192.168</span>.1.100 netmask <span class="token number">255.255</span>.255.0 up 命令配置 bond0 的 IP 地址和子网掩码，并启用 bond0 接口。echo <span class="token string">"192.168.1.1 via bond0"</span> <span class="token operator">>></span> /etc/sysconfig/network-scripts/route-bond0 命令配置 bond0 的默认网关。echo <span class="token string">"nameserver 8.8.8.8"</span> <span class="token operator">></span> /etc/resolv.conf 和 <span class="token builtin class-name">echo</span> <span class="token string">"nameserver 8.8.4.4"</span> <span class="token operator">>></span> /etc/resolv.conf 命令配置 DNS 服务器的 IP 地址。

无论是基于配置文件还是命令完成 bond0 配置，都需要重启网络服务或者重启系统才能生效。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>通过ifconfig命令结果找到ip地址.<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">在终端中输入 <span class="token function">ifconfig</span> 命令，按下回车键。
在 <span class="token function">ifconfig</span> 命令的输出结果中，可以找到当前计算机的 IP 地址。通常情况下，IP 地址会显示在 inet 或 inet addr 字段后面，例如：

eth0      Link encap:Ethernet  HWaddr 00:11:22:33:44:55
          inet addr:192.168.1.100  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: fe80::211:22ff:fe33:4455/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:12345 errors:0 dropped:0 overruns:0 frame:0
          TX packets:6789 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:12345678 <span class="token punctuation">(</span><span class="token number">12.3</span> MB<span class="token punctuation">)</span>  TX bytes:567890 <span class="token punctuation">(</span><span class="token number">567.8</span> KB<span class="token punctuation">)</span>
在上面的示例中，eth0 是网卡名称，inet addr:192.168.1.100 表示当前计算机的 IP 地址为 <span class="token number">192.168</span>.1.100。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用脚本判断 你主机所在网络内在线的主机IP有哪些？ ping通则在线。<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">以下是一个使用 Bash 脚本判断本地网络内在线主机 IP 的示例：

<span class="token comment">#!/bin/bash</span>
<span class="token comment"># 获取本地 IP 地址和子网掩码</span>
<span class="token assign-left variable">ip</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ifconfig</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-A</span> <span class="token number">1</span> <span class="token string">'eth0'</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-1</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">' '</span> <span class="token parameter variable">-f</span> <span class="token number">1</span><span class="token variable">)</span></span>
<span class="token assign-left variable">subnet</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">ifconfig</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-A</span> <span class="token number">1</span> <span class="token string">'eth0'</span> <span class="token operator">|</span> <span class="token function">tail</span> <span class="token parameter variable">-1</span> <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">4</span><span class="token variable">)</span></span>

<span class="token comment"># 将子网掩码转换为 CIDR 格式</span>
<span class="token assign-left variable">cidr</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $subnet <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123; split($0, a, "."); print a[1]*256^3 + a[2]*256^2 + a[3]*256 + a[4] &#125;'</span> <span class="token operator">|</span> <span class="token function">awk</span> '<span class="token punctuation">&#123;</span> mask <span class="token operator">=</span> 0xFFFFFFFF <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">32</span> - log<span class="token punctuation">(</span>$1<span class="token punctuation">)</span>/log<span class="token punctuation">(</span><span class="token number">2</span><span class="token variable">)</span><span class="token variable">)</span></span><span class="token punctuation">;</span> print <span class="token number">32</span> - log<span class="token punctuation">(</span>mask<span class="token punctuation">)</span>/log<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token string">')

# 获取本地网络的 IP 段
network=$(echo $ip | awk -F '</span><span class="token builtin class-name">.</span><span class="token string">' '</span><span class="token punctuation">&#123;</span> print <span class="token variable">$1</span>,<span class="token variable">$2</span>,<span class="token variable">$3</span> <span class="token punctuation">&#125;</span><span class="token string">' OFS='</span>.' <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s/$/.0\/<span class="token variable">$cidr</span>/"</span><span class="token punctuation">)</span>

<span class="token comment"># 遍历本地网络内的 IP 地址</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">254</span><span class="token variable">)</span></span><span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token assign-left variable">address</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$network</span>.<span class="token variable">$i</span>"</span>
  <span class="token function">ping</span> <span class="token parameter variable">-c</span> <span class="token number">1</span> <span class="token parameter variable">-w</span> <span class="token number">1</span> <span class="token variable">$address</span> <span class="token operator">></span> /dev/null <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span>
  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token parameter variable">-eq</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$address</span> is online"</span>
  <span class="token keyword">fi</span>
<span class="token keyword">done</span>

该脚本的原理是通过获取本地 IP 地址和子网掩码，计算出本地网络的 IP 段，然后遍历该 IP 段内的所有 IP 地址，使用 <span class="token function">ping</span> 命令测试每个 IP 地址是否在线。如果 <span class="token function">ping</span> 命令返回值为 <span class="token number">0</span>，则表示该 IP 地址在线，输出该 IP 地址。
注意：该脚本中的 eth0 是网卡名称，如果你的网卡名称不是 eth0，需要将脚本中的 eth0 替换为你的网卡名称。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>使用while read line和&#x2F;etc&#x2F;passwd，计算用户id总和<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">可以使用 <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line 和 /etc/passwd 文件来计算用户 ID 的总和。以下是一个示例脚本：

<span class="token comment">#!/bin/bash</span>
<span class="token assign-left variable">sum</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">while</span> <span class="token builtin class-name">read</span> line<span class="token punctuation">;</span> <span class="token keyword">do</span>
  <span class="token assign-left variable">uid</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> $line <span class="token operator">|</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">':'</span> <span class="token parameter variable">-f</span> <span class="token number">3</span><span class="token variable">)</span></span>
  <span class="token assign-left variable">sum</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>sum <span class="token operator">+</span> uid<span class="token variable">))</span></span>
<span class="token keyword">done</span> <span class="token operator">&lt;</span> /etc/passwd

<span class="token builtin class-name">echo</span> <span class="token string">"Total UID: <span class="token variable">$sum</span>"</span>

该脚本的原理是使用 <span class="token keyword">while</span> <span class="token builtin class-name">read</span> line 循环读取 /etc/passwd 文件中的每一行，然后使用 <span class="token function">cut</span> 命令提取每行中的用户 ID（第三个字段），并将其累加到 <span class="token function">sum</span> 变量中。最后输出 <span class="token function">sum</span> 变量的值，即为用户 ID 的总和。
注意：该脚本需要使用 root 权限运行，因为只有 root 用户才有权限读取 /etc/passwd 文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>​	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://www.sujx.net">靖轩</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://www.sujx.net/2023/05/21/magedu-week-3/">https://www.sujx.net/2023/05/21/magedu-week-3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.sujx.net/about/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/05/14/magedu-week-2/" title="Linux系统基础知识·2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Linux系统基础知识·2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.sujx.net/about/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">靖轩</div><div class="author-info__description">逝者如斯夫,不舍昼夜</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">179</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/sujx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/grepsu" target="_blank" title="Gitee"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sujx@live.cn" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS链接"><i class="fa  fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">软件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">网络相关</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/21/magedu-week-3/" title="Linux系统基础知识·3">Linux系统基础知识·3</a><time datetime="2023-05-21T14:48:47.000Z" title="Created 2023-05-21 22:48:47">2023-05-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/14/magedu-week-2/" title="Linux系统基础知识·2">Linux系统基础知识·2</a><time datetime="2023-05-14T14:48:47.000Z" title="Created 2023-05-14 22:48:47">2023-05-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/10/magedu-week-1/" title="Linux系统基础知识·1">Linux系统基础知识·1</a><time datetime="2023-04-10T08:35:34.000Z" title="Created 2023-04-10 16:35:34">2023-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/03/How2UseKVM/" title="内核虚拟化KVM的使用">内核虚拟化KVM的使用</a><time datetime="2022-11-03T14:22:22.000Z" title="Created 2022-11-03 22:22:22">2022-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/19/clean-old-kernel/" title="CentOS主机清理旧内核">CentOS主机清理旧内核</a><time datetime="2022-10-19T06:48:47.000Z" title="Created 2022-10-19 14:48:47">2022-10-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.sujx.net/about/footimg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 靖轩</div><div class="footer_custom_text">京ICP备17034757号-1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>